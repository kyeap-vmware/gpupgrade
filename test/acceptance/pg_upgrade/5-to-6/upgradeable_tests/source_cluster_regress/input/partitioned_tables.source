-- Copyright (c) 2017-2023 VMware, Inc. or its affiliates
-- SPDX-License-Identifier: Apache-2.0

--------------------------------------------------------------------------------
-- Tests to ensure that various flavors of partitioned tables are functional post-upgrade
--
-- Tests are inspired by:
-- gpdb/src/test/regress/sql/partition.sql
-- gpdb/src/test/regress/sql/partition_indexing.sql
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------
DROP FUNCTION IF EXISTS root_partition_indexes();
CREATE FUNCTION root_partition_indexes() RETURNS TABLE(table_name NAME, index_name REGCLASS,indisvalid boolean, column_num smallint, column_name NAME)
  LANGUAGE SQL STABLE STRICT AS $fn$
  WITH indexes AS (
    SELECT *, unnest(indkey) AS column_num
    FROM pg_index
  )
  SELECT DISTINCT
  c.relname as table_name,
  indexrelid::regclass as index_name,
  indisvalid,
  column_num,
  a.attname
  FROM indexes pi
  JOIN pg_partition pp ON pi.indrelid = pp.parrelid
  JOIN pg_class c on c.oid=pi.indrelid
  JOIN pg_class pc ON pc.oid = pp.parrelid
  JOIN pg_attribute a on a.attrelid = pi.indrelid AND a.attnum = pi.column_num
  ORDER BY 1, 2, 4
$fn$;

DROP FUNCTION IF EXISTS child_partition_indexes();
CREATE FUNCTION child_partition_indexes() RETURNS TABLE(table_name NAME, index_name REGCLASS, indisvalid boolean, has_child boolean, column_num smallint, column_name NAME)
  LANGUAGE SQL STABLE STRICT AS $fn$
  WITH indexes AS (
    SELECT *, unnest(indkey) AS column_num
    FROM pg_index
  )
  SELECT DISTINCT
  c.relname as table_name,
  indexrelid::regclass as index_name,
  indisvalid,
  pc.relhassubclass as has_child,
  column_num,
  a.attname
  FROM indexes pi
  JOIN pg_partition_rule pp ON pi.indrelid=pp.parchildrelid
  JOIN pg_class c on c.oid=pi.indrelid
  JOIN pg_class pc ON pc.oid=pp.parchildrelid
  JOIN pg_attribute a on a.attrelid = pi.indrelid AND a.attnum = pi.column_num
  ORDER by 1, 2, 4, 5
$fn$;

--------------------------------------------------------------------------------
-- Use the indexes whenever possible
--------------------------------------------------------------------------------
SET enable_indexscan = true;
SET enable_bitmapscan = true;
SET enable_seqscan = false;
SET optimizer = off;

--------------------------------------------------------------------------------
-- AO PARTITIONED TABLE WITH MULTIPLE SEGFILES AND DELETED TUPLES
--------------------------------------------------------------------------------

CREATE TABLE p_ao_table_with_multiple_segfiles (id int, name text) WITH (appendonly=true) DISTRIBUTED BY (id)
    PARTITION BY RANGE (id)
        SUBPARTITION BY LIST (name)
            SUBPARTITION TEMPLATE (
            SUBPARTITION jane VALUES ('Jane'),
            SUBPARTITION john VALUES ('John'),
            DEFAULT SUBPARTITION other_names )
        (START (1) END (2) EVERY (1),
        DEFAULT PARTITION other_ids);

CREATE INDEX p_ao_table_with_multiple_segfiles_idx ON p_ao_table_with_multiple_segfiles(id);

-- Use multiple sessions to create multiple segfiles
1:BEGIN;
1:INSERT INTO p_ao_table_with_multiple_segfiles VALUES (1, 'Jane');
1:INSERT INTO p_ao_table_with_multiple_segfiles VALUES (2, 'Jane');

2:BEGIN;
2:INSERT INTO p_ao_table_with_multiple_segfiles VALUES (1, 'Jane');
2:INSERT INTO p_ao_table_with_multiple_segfiles VALUES (2, 'Jane');
2:INSERT INTO p_ao_table_with_multiple_segfiles VALUES (4, 'Andy');

1:END;
2:END;

UPDATE p_ao_table_with_multiple_segfiles SET name='Carolyn' WHERE name='Andy';
INSERT INTO p_ao_table_with_multiple_segfiles VALUES (5, 'Bob');
DELETE FROM p_ao_table_with_multiple_segfiles WHERE id=5;


--------------------------------------------------------------------------------
-- AOCO PARTITIONED TABLE WITH MULTIPLE SEGFILES AND DELETED TUPLES
--------------------------------------------------------------------------------

CREATE TABLE p_aoco_table_with_multiple_segfiles (id int, name text) WITH (appendonly=true, orientation=column) DISTRIBUTED BY (id)
PARTITION BY RANGE (id)
    SUBPARTITION BY LIST (name)
        SUBPARTITION TEMPLATE (
         SUBPARTITION jane VALUES ('Jane'),
          SUBPARTITION john VALUES ('John'),
           DEFAULT SUBPARTITION other_names )
(START (1) END (2) EVERY (1),
    DEFAULT PARTITION other_ids);

CREATE INDEX p_aoco_table_with_multiple_segfiles_idx ON p_aoco_table_with_multiple_segfiles(id);

-- Use multiple sessions to create multiple segfiles
1:BEGIN;
1:INSERT INTO p_aoco_table_with_multiple_segfiles VALUES (1, 'Jane');
1:INSERT INTO p_aoco_table_with_multiple_segfiles VALUES (2, 'Jane');

2:BEGIN;
2:INSERT INTO p_aoco_table_with_multiple_segfiles VALUES (1, 'Jane');
2:INSERT INTO p_aoco_table_with_multiple_segfiles VALUES (2, 'Jane');
2:INSERT INTO p_aoco_table_with_multiple_segfiles VALUES (4, 'Andy');

1:END;
2:END;

UPDATE p_aoco_table_with_multiple_segfiles SET name='Carolyn' WHERE name='Andy';
INSERT INTO p_aoco_table_with_multiple_segfiles VALUES (5, 'Bob');
DELETE FROM p_aoco_table_with_multiple_segfiles WHERE id=5;

--------------------------------------------------------------------------------
-- POLYMORPHIC PARTITIONED TABLES
-- Test to ensure that partitioned polymorphic tables can be
-- upgraded. We create the tables with 2 heap, 1 AO, 1 AOCO, and 1
-- external partitions. The root partition of each table will be
-- either heap or AOCO.
--------------------------------------------------------------------------------

CREATE TABLE poly_range_partition_with_heap_root (a int, b int)
PARTITION BY RANGE(b)
(
    PARTITION ext_part START(0) END(2),
    PARTITION ao_part START(2) END(4) WITH (appendonly=true),
    PARTITION aoco_part START(4) END(6) WITH (appendonly=true, orientation=column),
    PARTITION heap_part_1 START(6) END(8) WITH (appendonly=false),
    PARTITION heap_part_2 START(8) END(10) WITH (appendonly=false)
);
CREATE INDEX poly_range_partition_with_heap_root_idx ON poly_range_partition_with_heap_root(a);

CREATE EXTERNAL TABLE external_table (a int, b int) LOCATION ('file://@hostname@/@abs_srcdir@/data/one_level_external_table_data.csv') FORMAT 'TEXT' (DELIMITER '|');
ALTER TABLE poly_range_partition_with_heap_root EXCHANGE PARTITION ext_part WITH TABLE external_table WITHOUT VALIDATION;
DROP TABLE external_table;

INSERT INTO poly_range_partition_with_heap_root SELECT i, i FROM generate_series(2, 9)i;

SELECT * FROM poly_range_partition_with_heap_root ORDER BY 1;
SELECT * FROM poly_range_partition_with_heap_root WHERE a < 5 ORDER BY 1;

CREATE TABLE poly_range_partition_with_aoco_root (a int, b int) WITH (appendonly=true, orientation=column)
PARTITION BY RANGE(b)
(
    PARTITION ext_part START(0) END(2),
    PARTITION ao_part START(2) END(4) WITH (appendonly=true),
    PARTITION aoco_part START(4) END(6) WITH (appendonly=true, orientation=column),
    PARTITION heap_part_1 START(6) END(8) WITH (appendonly=false),
    PARTITION heap_part_2 START(8) END(10) WITH (appendonly=false)
);

CREATE INDEX poly_range_partition_with_aoco_root_idx ON poly_range_partition_with_aoco_root(a);

CREATE EXTERNAL TABLE external_table (a int, b int) LOCATION ('file://@hostname@/@abs_srcdir@/data/one_level_external_table_data.csv') FORMAT 'TEXT' (DELIMITER '|');
ALTER TABLE poly_range_partition_with_aoco_root EXCHANGE PARTITION ext_part WITH TABLE external_table WITHOUT VALIDATION;
DROP TABLE external_table;

INSERT INTO poly_range_partition_with_aoco_root SELECT i, i FROM generate_series(2, 9)i;

SELECT * FROM poly_range_partition_with_aoco_root ORDER BY 1;
SELECT * FROM poly_range_partition_with_aoco_root WHERE a < 5 ORDER BY 1;

CREATE TABLE poly_list_partition_with_heap_root (a int, b int)
PARTITION BY LIST(b)
(
    PARTITION ext_part VALUES (0, 1),
    PARTITION ao_part VALUES(2, 3) WITH (appendonly=true),
    PARTITION aoco_part VALUES(4, 5) WITH (appendonly=true, orientation=column),
    PARTITION heap_part_1 VALUES(6, 7) WITH (appendonly=false),
    PARTITION heap_part_2 VALUES(8, 9) WITH (appendonly=false)
);

CREATE INDEX poly_list_partition_with_heap_root_idx ON poly_list_partition_with_heap_root(a);

CREATE EXTERNAL TABLE external_table (a int, b int) LOCATION ('file://@hostname@/@abs_srcdir@/data/one_level_external_table_data.csv') FORMAT 'TEXT' (DELIMITER '|');
ALTER TABLE poly_list_partition_with_heap_root EXCHANGE PARTITION ext_part WITH TABLE external_table WITHOUT VALIDATION;
DROP TABLE external_table;

INSERT INTO poly_list_partition_with_heap_root SELECT i, i FROM generate_series(2, 9)i;

SELECT * FROM poly_list_partition_with_heap_root ORDER BY 1;
SELECT * FROM poly_list_partition_with_heap_root WHERE a < 5 ORDER BY 1;

CREATE TABLE poly_list_partition_with_aoco_root (a int, b int) WITH (appendonly=true, orientation=column)
PARTITION BY LIST(b)
(
    PARTITION ext_part VALUES (0, 1),
    PARTITION ao_part VALUES(2, 3) WITH (appendonly=true),
    PARTITION aoco_part VALUES(4, 5) WITH (appendonly=true, orientation=column),
    PARTITION heap_part_1 VALUES(6, 7) WITH (appendonly=false),
    PARTITION heap_part_2 VALUES(8, 9) WITH (appendonly=false)
);

CREATE INDEX poly_list_partition_with_aoco_root_idx ON poly_list_partition_with_aoco_root(a);

CREATE EXTERNAL TABLE external_table (a int, b int) LOCATION ('file://@hostname@/@abs_srcdir@/data/one_level_external_table_data.csv') FORMAT 'TEXT' (DELIMITER '|');
ALTER TABLE poly_list_partition_with_aoco_root EXCHANGE PARTITION ext_part WITH TABLE external_table WITHOUT VALIDATION;
DROP TABLE external_table;

INSERT INTO poly_list_partition_with_aoco_root SELECT i, i FROM generate_series(2, 9)i;

SELECT * FROM poly_list_partition_with_aoco_root ORDER BY 1;
SELECT * FROM poly_list_partition_with_aoco_root WHERE a < 5 ORDER BY 1;

-- Show what the storage types of each partition are before upgrade
SELECT relname, relstorage FROM pg_class WHERE relname SIMILAR TO 'poly_(list|range)_partition_with_(heap|aoco)_root%' AND relkind IN ('r') ORDER BY relname;

--------------------------------------------------------------------------------
-- MISMATCHED AO PARTITIONED TABLE INDEXES
-- Test upgrade of an AO partition hierarchy having an index defined on the parent, that is
-- not defined on all of the members of the hierarchy.
--------------------------------------------------------------------------------

CREATE TABLE mismatched_aopartition_indexes (a integer, b text, c integer) WITH (appendonly=true) DISTRIBUTED BY (a) PARTITION BY RANGE(c) (START(1) END(3) EVERY(1));
CREATE INDEX mismatch_idx on mismatched_aopartition_indexes(b);

CREATE TABLE mismatch_exch (a integer, b text, c integer) WITH (appendonly=true) DISTRIBUTED BY (a);
ALTER TABLE mismatched_aopartition_indexes exchange partition for (rank(1)) with table mismatch_exch;

INSERT INTO mismatched_aopartition_indexes VALUES(1, 'apple', 1), (2, 'boss', 2);

SELECT * FROM mismatched_aopartition_indexes WHERE b = 'apple' ORDER BY 1;

--------------------------------------------------------------------------------
-- PARTITIONED TABLES USING KEYWORDS
-- Ensure that partition names having keywords (reserved, non-reserved and
-- unclassified) can be upgraded by quoting them using the quote_all_identifiers
-- GUC.
--------------------------------------------------------------------------------

--
-- Create a partitioned table using reserved (ie: "window"), non-reserved
-- (ie: "current"), and unclassified (ie: "allocate") keywords for partition names.
-- For a comprehensive list of keywords:
-- https://www.postgresql.org/docs/8.3/sql-keywords-appendix.html
CREATE TABLE t_quote_test (a int, b int, c int, d int, e text)
    DISTRIBUTED BY (a)
    PARTITION BY RANGE (b)
        SUBPARTITION BY RANGE (c)
            SUBPARTITION TEMPLATE (
            START (1) END (2) EVERY (1),
            DEFAULT SUBPARTITION "current" )
        SUBPARTITION BY LIST (e)
            SUBPARTITION TEMPLATE (
            SUBPARTITION "allocate" VALUES ('val1'),
            SUBPARTITION "window" VALUES ('val2'),
            DEFAULT SUBPARTITION dsp )
        ( START (2002) END (2003) EVERY (1),
        DEFAULT PARTITION dp );

-- Create indexes with reserved keywords
CREATE INDEX "both" ON t_quote_test(a);
CREATE INDEX "column" ON t_quote_test(e);

INSERT INTO t_quote_test SELECT i, i, i, i, 'val' || i FROM generate_series(1, 10) i;

SELECT * FROM t_quote_test WHERE a < 5 ORDER BY 1;
SELECT * FROM t_quote_test WHERE e = 'val10' ORDER BY 1;

--------------------------------------------------------------------------------
-- PARTITION CHILDREN IN DIFFERENT SCHEMAS
--------------------------------------------------------------------------------

CREATE SCHEMA schema1;
CREATE SCHEMA schema2;
CREATE TABLE public.different_schema_ptable(a int, b int) PARTITION BY RANGE(a) (START(1) END (4) EVERY(1));

ALTER TABLE public.different_schema_ptable_1_prt_1 SET SCHEMA schema1;
ALTER TABLE public.different_schema_ptable_1_prt_2 SET SCHEMA schema2;

CREATE INDEX different_schema_ptable_idx ON public.different_schema_ptable(b);

INSERT INTO public.different_schema_ptable SELECT i, i + 1 FROM generate_series(1, 3) i;

-- check data
SELECT * FROM public.different_schema_ptable ORDER BY 1, 2;
SELECT * FROM schema1.different_schema_ptable_1_prt_1 ORDER BY 1, 2;
SELECT * FROM schema2.different_schema_ptable_1_prt_2 ORDER BY 1, 2;
SELECT * FROM public.different_schema_ptable_1_prt_3 ORDER BY 1, 2;

-- check partition schemas
SELECT nsp.nspname, c.relname
FROM pg_class c
JOIN pg_namespace nsp ON nsp.oid = c.relnamespace
WHERE relname LIKE 'different_schema_ptable%'
ORDER BY relname;

--------------------------------------------------------------------------------
-- MULTILEVEL PARTITION CHILDREN IN DIFFERENT SCHEMAS
--------------------------------------------------------------------------------

CREATE TABLE multilevel_different_schema_ptable (id int, year date, gender char(1))
DISTRIBUTED BY (id, gender, year)
partition BY list (gender)
subpartition BY range (year)
subpartition template (
START (date '2001-01-01'),
START (date '2002-01-01'),
START (date '2003-01-01')
)
(
  partition boys VALUES ('M'),
  partition girls VALUES ('F')
);

CREATE INDEX multilevel_different_schema_ptable_idx ON multilevel_different_schema_ptable(id);

ALTER TABLE public.multilevel_different_schema_ptable_1_prt_boys SET SCHEMA schema1;
ALTER TABLE public.multilevel_different_schema_ptable_1_prt_girls_2_prt_1 SET SCHEMA schema1;
ALTER TABLE public.multilevel_different_schema_ptable_1_prt_girls_2_prt_2 SET SCHEMA schema2;

INSERT INTO public.multilevel_different_schema_ptable VALUES (1, date '2001-01-15', 'M');
INSERT INTO public.multilevel_different_schema_ptable VALUES (2, date '2002-02-15', 'M');
INSERT INTO public.multilevel_different_schema_ptable VALUES (3, date '2003-03-15', 'M');
INSERT INTO public.multilevel_different_schema_ptable VALUES (4, date '2001-01-15', 'F');
INSERT INTO public.multilevel_different_schema_ptable VALUES (5, date '2002-02-15', 'F');
INSERT INTO public.multilevel_different_schema_ptable VALUES (6, date '2003-03-15', 'F');

-- check data
SELECT * FROM public.multilevel_different_schema_ptable ORDER BY 1, 2, 3;
SELECT * FROM schema1.multilevel_different_schema_ptable_1_prt_boys ORDER BY 1, 2, 3;
SELECT * FROM public.multilevel_different_schema_ptable_1_prt_boys_2_prt_1 ORDER BY 1, 2, 3;
SELECT * FROM public.multilevel_different_schema_ptable_1_prt_boys_2_prt_2 ORDER BY 1, 2, 3;
SELECT * FROM public.multilevel_different_schema_ptable_1_prt_boys_2_prt_3 ORDER BY 1, 2, 3;
SELECT * FROM public.multilevel_different_schema_ptable_1_prt_girls ORDER BY 1, 2, 3;
SELECT * FROM schema1.multilevel_different_schema_ptable_1_prt_girls_2_prt_1 ORDER BY 1, 2, 3;
SELECT * FROM schema2.multilevel_different_schema_ptable_1_prt_girls_2_prt_2 ORDER BY 1, 2, 3;
SELECT * FROM public.multilevel_different_schema_ptable_1_prt_girls_2_prt_3 ORDER BY 1, 2, 3;

-- check partition schemas
SELECT nsp.nspname, c.relname
FROM pg_class c
JOIN pg_namespace nsp ON nsp.oid = c.relnamespace
WHERE relname LIKE 'multilevel_different_schema_ptable%'
ORDER BY relname;

--------------------------------------------------------------------------------
-- DROPPED COLUMN
--------------------------------------------------------------------------------

CREATE TABLE pt_dropped_column (a int, b int, c int, d int) DISTRIBUTED BY (c)
    PARTITION BY RANGE (a)
        (PARTITION part_1 START(1) END(5),
        PARTITION part_2 START(5));
INSERT INTO pt_dropped_column SELECT i, i, i, i FROM generate_series(1, 10) i;
ALTER TABLE pt_dropped_column DROP COLUMN d;
INSERT INTO pt_dropped_column SELECT i, i, i FROM generate_series(10, 20) i;

--------------------------------------------------------------------------------
-- ROOT PARTITION HAS DROPPED COLUMN
--------------------------------------------------------------------------------

CREATE TABLE pt_root_has_dropped_column (a int, b int, c int, d int)
    PARTITION BY RANGE (a)
        (PARTITION part_1 START(1) END(5),
        PARTITION part_2 START(5));
INSERT INTO pt_root_has_dropped_column SELECT i, i, i, i FROM generate_series(1, 10) i;
ALTER TABLE pt_root_has_dropped_column DROP COLUMN d;

CREATE TABLE intermediate_table_1 (a int, b int, c int);
ALTER TABLE pt_root_has_dropped_column EXCHANGE PARTITION part_1 WITH TABLE intermediate_table_1;
DROP TABLE intermediate_table_1;

CREATE TABLE intermediate_table_2 (a int, b int, c int);
ALTER TABLE pt_root_has_dropped_column EXCHANGE PARTITION part_2 WITH TABLE intermediate_table_2;
DROP TABLE intermediate_table_2;

INSERT INTO pt_root_has_dropped_column SELECT i, i, i FROM generate_series(10, 20) i;

--------------------------------------------------------------------------------
-- DROPPED AND NEWLY ADDED COLUMN
--------------------------------------------------------------------------------
CREATE TABLE pt_dropped_and_added_column (a int, b int, c int, d numeric) DISTRIBUTED BY (a)
    PARTITION BY RANGE(c) SUBPARTITION BY range(d)
        (PARTITION part_1 START(0) END(42)
            (SUBPARTITION subpart_1 START(0) END(42)));

INSERT INTO pt_dropped_and_added_column SELECT i, i, i, i FROM generate_series(1, 10) i;
ALTER TABLE pt_dropped_and_added_column DROP COLUMN b;
ALTER TABLE pt_dropped_and_added_column ADD COLUMN e int;
INSERT INTO pt_dropped_and_added_column SELECT i, i, i, i FROM generate_series(10, 20) i;

--------------------------------------------------------------------------------
-- ALTER OWNER
--------------------------------------------------------------------------------

CREATE TABLE pt_alter_owner (id INTEGER, name TEXT) DISTRIBUTED BY (id) PARTITION BY RANGE(id) (START(1) END(3) EVERY(1));
ALTER TABLE pt_alter_owner OWNER TO upgradable_objects_role;

--------------------------------------------------------------------------------
-- LIST PARTITIONED BY CUSTOM TYPE
-- This tests the scenario where a list partitioned table is partitioned by a custom type
-- where the equality operator is in a different schema.
-- Note: On 5X, inserts into the table won't work due to a bug where it assumes
--       the equality operator is in pg_catalog. This is fixed in 6X so we'll at
--       least test the table creation here.
--------------------------------------------------------------------------------
CREATE TYPE equal_operator_not_in_search_path_type AS (a int, b int);
CREATE FUNCTION equal_operator_not_in_search_path_func (equal_operator_not_in_search_path_type, equal_operator_not_in_search_path_type) RETURNS boolean
  AS 'SELECT $1.a = $2.a;'
  LANGUAGE SQL IMMUTABLE
  RETURNS NULL ON NULL INPUT;

CREATE SCHEMA equal_operator_not_in_search_path_schema;
CREATE OPERATOR equal_operator_not_in_search_path_schema.= (
        LEFTARG = equal_operator_not_in_search_path_type,
        RIGHTARG = equal_operator_not_in_search_path_type,
        PROCEDURE = equal_operator_not_in_search_path_func
);

CREATE OPERATOR CLASS equal_operator_not_in_search_path_opclass
  DEFAULT FOR TYPE equal_operator_not_in_search_path_type
  USING btree AS
  OPERATOR 3 equal_operator_not_in_search_path_schema.=;

SET search_path TO equal_operator_not_in_search_path_schema,"$user",public;
CREATE TABLE public.equal_operator_not_in_search_path_table (a int, b equal_operator_not_in_search_path_type)
DISTRIBUTED BY (a) PARTITION BY LIST(b)
(
  PARTITION part1 VALUES('(1,1)')
);

CREATE TABLE public.equal_operator_not_in_search_path_table_multi_key (a int, b equal_operator_not_in_search_path_type, c int)
DISTRIBUTED BY (a) PARTITION BY LIST(b, c)
(
  PARTITION part1 VALUES(('(1,1)', 1))
);

RESET search_path;

--------------------------------------------------------------------------------
-- PARTITION INDEX INHERITANCE TESTS
--------------------------------------------------------------------------------

CREATE TABLE pt_inh_t1 (a INTEGER NOT NULL, b CHAR(25)) DISTRIBUTED BY (a)
PARTITION BY range (a)
(PARTITION part1 START (0));

CREATE INDEX pt_inh_t1_idx ON pt_inh_t1(a);

SELECT * FROM root_partition_indexes() WHERE table_name LIKE 'pt_inh_t1%';
SELECT * FROM child_partition_indexes() WHERE table_name LIKE 'pt_inh_t1%';

CREATE TABLE pt_inh_t2 (a INTEGER NOT NULL, b CHAR(25)) DISTRIBUTED BY (a)
PARTITION BY range (a)
SUBPARTITION BY list (b) SUBPARTITION TEMPLATE
(SUBPARTITION a VALUES ('A'))
(PARTITION part1 START (0));

CREATE INDEX pt_inh_t2_idx ON pt_inh_t2(a);

SELECT * FROM root_partition_indexes() WHERE table_name LIKE 'pt_inh_t2%';
SELECT * FROM child_partition_indexes() WHERE table_name LIKE 'pt_inh_t2%';

--------------------------------------------------------------------------------
-- HEAP PARTITIONED TABLE INDEXES
--------------------------------------------------------------------------------

CREATE TABLE pt_heap (
        unique1         int4,
        unique2         int4,
        two             int4,
        four            int4,
        ten             int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        even            int4,
        odd             int4,
        stringu1        name,
        stringu2        name,
        string4         name
) distributed by (unique1) partition by range (unique1)
subpartition by range (unique2)
subpartition template (
  subpartition subpart1 start (0) end (20) inclusive every (10))
( partition part1 start (0) end (10));

CREATE UNIQUE INDEX pt_heap_unique1_uniqueidx ON pt_heap(unique1);
CREATE INDEX pt_heap_unique2_idx ON pt_heap(unique2);
CREATE INDEX pt_heap_unique1_unique2_idx ON pt_heap(unique1, unique2);
CREATE INDEX pt_heap_two_four_idx ON pt_heap(two, four);
CREATE INDEX pt_heap_string4_bitmap_idx ON pt_heap using bitmap(string4);
CREATE INDEX pt_heap_ten_twenty_bitmap_idx ON pt_heap using bitmap(ten, twenty);

-- Dropped root partition index
CREATE INDEX pt_heap_dropped_root_idx ON pt_heap(hundred);
DROP INDEX pt_heap_dropped_root_idx;

-- Dropped child partition index
CREATE INDEX pt_heap_dropped_child_subpart1_idx ON pt_heap(thousand);
DROP INDEX pt_heap_dropped_child_subpart1_idx_1_prt_part1_2_prt_subpart1_1;

-- Create index on mid-level partition. This won't be used unless
-- querying the mid-level partition directly.
CREATE INDEX pt_heap_mid_idx ON pt_heap_1_prt_part1(twothousand);

-- Create index on leaf partition
CREATE INDEX pt_heap_leaf_idx ON pt_heap_1_prt_part1_2_prt_subpart1_2(fivethous);

-- Add partition
ALTER TABLE pt_heap ADD PARTITION added_part START (11) END (15) inclusive;

-- Add default partition
ALTER TABLE pt_heap ADD DEFAULT PARTITION default_part;

-- Exchange partition with index
CREATE TABLE pt_heap_exchange1 (LIKE pt_heap);
CREATE INDEX pt_heap_exchange1_idx ON pt_heap_exchange1(stringu1);
ALTER TABLE pt_heap ALTER PARTITION part1 EXCHANGE PARTITION FOR (0) WITH TABLE pt_heap_exchange1;
DROP TABLE pt_heap_exchange1;

-- Exchange partition without index
CREATE TABLE pt_heap_exchange2 (LIKE pt_heap);
ALTER TABLE pt_heap ALTER PARTITION FOR (RANK(2)) EXCHANGE PARTITION FOR (5) WITH TABLE pt_heap_exchange2;
DROP TABLE pt_heap_exchange2;

-- Insert data
COPY pt_heap FROM '@abs_srcdir@/data/indexes.data';

-- Create index on column, then drop column
CREATE INDEX pt_heap_index_on_dropped_column ON pt_heap(tenthous);
ALTER TABLE pt_heap DROP COLUMN tenthous;

-- Check the indexes

-- pt_heap_unique1_uniqueidx
SELECT * FROM pt_heap WHERE unique1 < 10 ORDER BY 1;

-- pt_heap_unique2_idx
SELECT * FROM pt_heap WHERE unique2 < 10 ORDER BY 1;

-- pt_heap_unique1_unique2_idx
SELECT * FROM pt_heap WHERE unique1 < 10 and unique2 < 15 ORDER BY 1;

-- pt_heap_two_four_idx
SELECT * FROM pt_heap WHERE two = 1 and four = 3 ORDER BY 1;

-- pt_heap_string4_bitmap_idx
SELECT * FROM pt_heap WHERE stringu2 = 'WAAAAA' and string4 = 'OOOOxx' ORDER BY 1;

-- pt_heap_ten_twenty_bitmap_idx
SELECT * FROM pt_heap WHERE ten = 9 and twenty = 19 ORDER BY 1;

-- pt_heap_dropped_root_idx
SELECT * FROM pt_heap WHERE hundred=5 ORDER BY 1;

-- pt_heap_mid_idx
SELECT * FROM pt_heap_1_prt_part1 WHERE twothousand = 46 ORDER BY 1;

-- pt_heap_leaf_idx
SELECT * FROM pt_heap WHERE fivethous=346 ORDER BY 1;

-- pt_heap_exchange1_idx
SELECT * FROM pt_heap WHERE stringu1 = 'JMAAAA' ORDER BY 1;

--------------------------------------------------------------------------------
-- AO PARTITIONED TABLE INDEXES
--------------------------------------------------------------------------------

SET gp_default_storage_options='appendonly=true';
CREATE TABLE pt_ao (
        unique1         int4,
        unique2         int4,
        two             int4,
        four            int4,
        ten             int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        even            int4,
        odd             int4,
        stringu1        name,
        stringu2        name,
        string4         name
) distributed by (unique1) partition by range (unique1)
subpartition by range (unique2)
subpartition template (
  subpartition subpart1 start (0) end (20) inclusive every (10))
( partition part1 start (0) end (10));

--- AO/CO tables do not support unique indexes on GPDB5/6
CREATE INDEX pt_ao_unique1_idx ON pt_ao(unique1);
CREATE INDEX pt_ao_unique2_idx ON pt_ao(unique2);
CREATE INDEX pt_ao_unique1_unique2_idx ON pt_ao(unique1, unique2);
CREATE INDEX pt_ao_two_four_idx ON pt_ao(two, four);
CREATE INDEX pt_ao_string4_bitmap_idx ON pt_ao using bitmap(string4);
CREATE INDEX pt_ao_ten_twenty_bitmap_idx ON pt_ao using bitmap(ten, twenty);

-- Dropped root partition index
CREATE INDEX pt_ao_dropped_root_idx ON pt_ao(hundred);
DROP INDEX pt_ao_dropped_root_idx;

-- Dropped child partition index
CREATE INDEX pt_ao_dropped_child_subpart1_idx ON pt_ao(thousand);
DROP INDEX pt_ao_dropped_child_subpart1_idx_1_prt_part1_2_prt_subpart1_1;

-- Create index on mid-level partition. This won't be used unless
-- querying the mid-level partition directly.
CREATE INDEX pt_ao_mid_idx ON pt_ao_1_prt_part1(twothousand);

-- Create index on leaf partition
CREATE INDEX pt_ao_leaf_idx ON pt_ao_1_prt_part1_2_prt_subpart1_2(fivethous);

-- Add partition
ALTER TABLE pt_ao ADD PARTITION added_part START (11) END (15) inclusive;

-- Add default partition
ALTER TABLE pt_ao ADD DEFAULT PARTITION default_part;

-- Exchange partition with index
CREATE TABLE pt_ao_exchange1 (LIKE pt_ao);
CREATE INDEX pt_ao_exchange1_idx ON pt_ao_exchange1(stringu1);
ALTER TABLE pt_ao ALTER PARTITION part1 EXCHANGE PARTITION FOR (0) WITH TABLE pt_ao_exchange1;
DROP TABLE pt_ao_exchange1;

-- Exchange partition without index
CREATE TABLE pt_ao_exchange2 (LIKE pt_ao);
ALTER TABLE pt_ao ALTER PARTITION FOR (RANK(2)) EXCHANGE PARTITION FOR (5) WITH TABLE pt_ao_exchange2;
DROP TABLE pt_ao_exchange2;

-- Insert data
COPY pt_ao FROM '@abs_srcdir@/data/indexes.data';

-- Create index on column, then drop column
CREATE INDEX pt_ao_index_on_dropped_column ON pt_ao(tenthous);
ALTER TABLE pt_ao DROP COLUMN tenthous;

RESET gp_default_storage_options;

-- Check the indexes

-- pt_ao_unique1_uniqueidx
SELECT * FROM pt_ao WHERE unique1 < 10 ORDER BY 1;

-- pt_ao_unique2_idx
SELECT * FROM pt_ao WHERE unique2 < 10 ORDER BY 1;

-- pt_ao_unique1_unique2_idx
SELECT * FROM pt_ao WHERE unique1 < 10 and unique2 < 15 ORDER BY 1;

-- pt_ao_two_four_idx
SELECT * FROM pt_ao WHERE two = 1 and four = 3 ORDER BY 1;

-- pt_ao_string4_bitmap_idx
SELECT * FROM pt_ao WHERE stringu2 = 'WAAAAA' and string4 = 'OOOOxx' ORDER BY 1;

-- pt_ao_ten_twenty_bitmap_idx
SELECT * FROM pt_ao WHERE ten = 9 and twenty = 19 ORDER BY 1;

-- pt_ao_dropped_root_idx
SELECT * FROM pt_ao WHERE hundred=5 ORDER BY 1;

-- pt_ao_mid_idx
SELECT * FROM pt_ao_1_prt_part1 WHERE twothousand = 46 ORDER BY 1;

-- pt_ao_leaf_idx
SELECT * FROM pt_ao WHERE fivethous=346 ORDER BY 1;

-- pt_ao_exchange1_idx
SELECT * FROM pt_ao WHERE stringu1 = 'JMAAAA' ORDER BY 1;


--------------------------------------------------------------------------------
-- AOCO PARTITIONED TABLE INDEXES
--------------------------------------------------------------------------------

SET gp_default_storage_options='appendonly=true,orientation=column';
CREATE TABLE pt_aoco (
        unique1         int4,
        unique2         int4,
        two             int4,
        four            int4,
        ten             int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        even            int4,
        odd             int4,
        stringu1        name,
        stringu2        name,
        string4         name
) distributed by (unique1) partition by range (unique1)
subpartition by range (unique2)
subpartition template (
  subpartition subpart1 start (0) end (20) inclusive every (10))
( partition part1 start (0) end (10));

--- AO/CO tables do not support unique indexes on GPDB5/6
CREATE INDEX pt_aoco_unique1_idx ON pt_aoco(unique1);
CREATE INDEX pt_aoco_unique2_idx ON pt_aoco(unique2);
CREATE INDEX pt_aoco_unique1_unique2_idx ON pt_aoco(unique1, unique2);
CREATE INDEX pt_aoco_two_four_idx ON pt_aoco(two, four);
CREATE INDEX pt_aoco_string4_bitmap_idx ON pt_aoco using bitmap(string4);
CREATE INDEX pt_aoco_ten_twenty_bitmap_idx ON pt_aoco using bitmap(ten, twenty);

-- Dropped root partition index
CREATE INDEX pt_aoco_dropped_root_idx ON pt_aoco(hundred);
DROP INDEX pt_aoco_dropped_root_idx;

-- Dropped child partition index
CREATE INDEX pt_aoco_dropped_child_subpart1_idx ON pt_aoco(thousand);
DROP INDEX pt_aoco_dropped_child_subpart1_idx_1_prt_part1_2_prt_subpart1_1;

-- Create index on mid-level partition. This won't be used unless
-- querying the mid-level partition directly.
CREATE INDEX pt_aoco_mid_idx ON pt_aoco_1_prt_part1(twothousand);

-- Create index on leaf partition
CREATE INDEX pt_aoco_leaf_idx ON pt_aoco_1_prt_part1_2_prt_subpart1_2(fivethous);

-- Add partition
ALTER TABLE pt_aoco ADD PARTITION added_part START (11) END (15) inclusive;

-- Add default partition
ALTER TABLE pt_aoco ADD DEFAULT PARTITION default_part;

-- Exchange partition with index
CREATE TABLE pt_aoco_exchange1 (LIKE pt_aoco);
CREATE INDEX pt_aoco_exchange1_idx ON pt_aoco_exchange1(stringu1);
ALTER TABLE pt_aoco ALTER PARTITION part1 EXCHANGE PARTITION FOR (0) WITH TABLE pt_aoco_exchange1;
DROP TABLE pt_aoco_exchange1;

-- Exchange partition without index
CREATE TABLE pt_aoco_exchange2 (LIKE pt_aoco);
ALTER TABLE pt_aoco ALTER PARTITION FOR (RANK(2)) EXCHANGE PARTITION FOR (5) WITH TABLE pt_aoco_exchange2;
DROP TABLE pt_aoco_exchange2;

-- Insert data
COPY pt_aoco FROM '@abs_srcdir@/data/indexes.data';

-- Create index on column, then drop column
CREATE INDEX pt_aoco_index_on_dropped_column ON pt_aoco(tenthous);
ALTER TABLE pt_aoco DROP COLUMN tenthous;

RESET gp_default_storage_options;

-- Check the indexes

-- pt_aoco_unique1_uniqueidx
SELECT * FROM pt_aoco WHERE unique1 < 10 ORDER BY 1;

-- pt_aoco_unique2_idx
SELECT * FROM pt_aoco WHERE unique2 < 10 ORDER BY 1;

-- pt_aoco_unique1_unique2_idx
SELECT * FROM pt_aoco WHERE unique1 < 10 and unique2 < 15 ORDER BY 1;

-- pt_aoco_two_four_idx
SELECT * FROM pt_aoco WHERE two = 1 and four = 3 ORDER BY 1;

-- pt_aoco_string4_bitmap_idx
SELECT * FROM pt_aoco WHERE stringu2 = 'WAAAAA' and string4 = 'OOOOxx' ORDER BY 1;

-- pt_aoco_ten_twenty_bitmap_idx
SELECT * FROM pt_aoco WHERE ten = 9 and twenty = 19 ORDER BY 1;

-- pt_aoco_dropped_root_idx
SELECT * FROM pt_aoco WHERE hundred=5 ORDER BY 1;

-- pt_aoco_mid_idx
SELECT * FROM pt_aoco_1_prt_part1 WHERE twothousand = 46 ORDER BY 1;

-- pt_aoco_leaf_idx
SELECT * FROM pt_aoco WHERE fivethous=346 ORDER BY 1;

-- pt_aoco_exchange1_idx
SELECT * FROM pt_aoco WHERE stringu1 = 'JMAAAA' ORDER BY 1;

--------------------------------------------------------------------------------
-- UNIQUE CONSTRAINT
--------------------------------------------------------------------------------

CREATE TABLE pt_unique_constraint(a int NOT NULL, b char(25)) DISTRIBUTED BY (a) PARTITION BY range (b) (PARTITION part1 START (0), PARTITION part2 START (5) END (8));

ALTER TABLE pt_unique_constraint ADD UNIQUE(a,b);
ALTER TABLE pt_unique_constraint ADD PARTITION added_part START (9);
ALTER TABLE pt_unique_constraint ADD DEFAULT PARTITION default_part;
ALTER TABLE pt_unique_constraint SPLIT PARTITION part2 AT (6) INTO (PARTITION part2_split_l, PARTITION part2_split_r);
ALTER TABLE pt_unique_constraint RENAME PARTITION part1 to part1_renamed;

INSERT INTO pt_unique_constraint SELECT i,i FROM generate_series(0, 10)i;

--------------------------------------------------------------------------------
-- UNIQUE CONSTRAINT WITH EXCHANGE
--------------------------------------------------------------------------------

CREATE TABLE pt_unique_exchange(a int NOT NULL, b char(25)) DISTRIBUTED BY (a) PARTITION BY range (b) (PARTITION part1 START (0), PARTITION part2 START (5) END (8));

ALTER TABLE pt_unique_exchange ADD UNIQUE(a,b);
CREATE TABLE pt_unq_exch (LIKE pt_unique_exchange INCLUDING CONSTRAINTS INCLUDING INDEXES);
ALTER TABLE pt_unique_exchange EXCHANGE PARTITION part1 WITH TABLE pt_unq_exch;
DROP TABLE pt_unq_exch;

INSERT INTO pt_unique_exchange SELECT i,i FROM generate_series(0, 7)i;

--------------------------------------------------------------------------------
-- UNIQUE CONSTRAINT INSIDE CREATE TABLE DDL
--------------------------------------------------------------------------------

CREATE TABLE pt_unique_inside_create_table(a int NOT NULL, b char(25), UNIQUE(a,b)) DISTRIBUTED BY (a) PARTITION BY range (b) (PARTITION part1 START (0), PARTITION part2 START (5) END (8));

INSERT INTO pt_unique_inside_create_table SELECT i,i FROM generate_series(0, 7)i;

--------------------------------------------------------------------------------
-- UNIQUE INDEX WITH UNIQUE CONSTRAINT HAVING SAME NAME
--------------------------------------------------------------------------------

CREATE TABLE pt_unique_index_same_name(a int NOT NULL, b char(25)) DISTRIBUTED BY (a) PARTITION BY range (b) (PARTITION part1 START (0), PARTITION part2 START (5) END (8));

CREATE INDEX pt_unique_index_same_name_a_key ON pt_unique_index_same_name(a,b);

ALTER TABLE pt_unique_index_same_name ADD UNIQUE(a,b);

INSERT INTO pt_unique_index_same_name SELECT i,i FROM generate_series(0, 7)i;
